{"ast":null,"code":"import { callBackend, fetchAppModules } from './moduleStructureAPI';\nexport async function fetchLogFormConfig(module) {\n  var _appModulesCache, _appModulesCache$data, _matched$modules$find;\n  const cacheKey = `${module}_formConfigCache`;\n  const cached = JSON.parse(sessionStorage.getItem(cacheKey));\n  const cacheDuration = 6 * 60 * 60 * 1000;\n  if (cached && Date.now() - cached.timestamp < cacheDuration) {\n    return cached.data;\n  }\n  let appModulesCache = JSON.parse(sessionStorage.getItem('appModulesCache'));\n\n  // ✅ Added fallback logic to fetch appModules if cache is not available\n  if (!appModulesCache || !appModulesCache.data) {\n    console.log(\"appModulesCache not found in session storage. Fetching from backend...\");\n    await fetchAppModules(true); // This will refresh sessionStorage\n    appModulesCache = JSON.parse(sessionStorage.getItem('appModulesCache'));\n  }\n  const matched = (_appModulesCache = appModulesCache) === null || _appModulesCache === void 0 ? void 0 : (_appModulesCache$data = _appModulesCache.data) === null || _appModulesCache$data === void 0 ? void 0 : _appModulesCache$data.find(group => group.modules.some(mod => mod.module === module));\n  const sheetId = matched === null || matched === void 0 ? void 0 : (_matched$modules$find = matched.modules.find(m => m.module === module)) === null || _matched$modules$find === void 0 ? void 0 : _matched$modules$find.sheetId;\n  if (!sheetId) throw new Error(`No sheetId found for ${module}`);\n\n  //  const payload = { sheetId, tab: 'config' };\n  const configRows = await callBackend('getSheetData', {\n    sheetId,\n    tab: 'config'\n  });\n  const dropdownMap = await callBackend('getSheetData', {\n    sheetId,\n    tab: 'dropdowns'\n  });\n  const finalData = {\n    configRows,\n    dropdownMap\n  };\n  sessionStorage.setItem(cacheKey, JSON.stringify({\n    data: finalData,\n    timestamp: Date.now()\n  }));\n  return finalData;\n}","map":{"version":3,"names":["callBackend","fetchAppModules","fetchLogFormConfig","module","_appModulesCache","_appModulesCache$data","_matched$modules$find","cacheKey","cached","JSON","parse","sessionStorage","getItem","cacheDuration","Date","now","timestamp","data","appModulesCache","console","log","matched","find","group","modules","some","mod","sheetId","m","Error","configRows","tab","dropdownMap","finalData","setItem","stringify"],"sources":["/Users/abhilash/Downloads/jp-internal-app/src/utils/logFormAPI.js"],"sourcesContent":["import { callBackend, fetchAppModules } from './moduleStructureAPI';\n\nexport async function fetchLogFormConfig(module) {\n  const cacheKey = `${module}_formConfigCache`;\n  const cached = JSON.parse(sessionStorage.getItem(cacheKey));\n  const cacheDuration = 6 * 60 * 60 * 1000;\n\n  if (cached && Date.now() - cached.timestamp < cacheDuration) {\n    return cached.data;\n  }\n\n  let appModulesCache = JSON.parse(sessionStorage.getItem('appModulesCache'));\n\n  // ✅ Added fallback logic to fetch appModules if cache is not available\n  if (!appModulesCache || !appModulesCache.data) {\n    console.log(\"appModulesCache not found in session storage. Fetching from backend...\");\n    await fetchAppModules(true); // This will refresh sessionStorage\n    appModulesCache = JSON.parse(sessionStorage.getItem('appModulesCache'));\n  }\n\n  const matched = appModulesCache?.data?.find(group =>\n    group.modules.some(mod => mod.module === module)\n  );\n\n  const sheetId = matched?.modules.find(m => m.module === module)?.sheetId;\n  if (!sheetId) throw new Error(`No sheetId found for ${module}`);\n\n//  const payload = { sheetId, tab: 'config' };\n  const configRows = await callBackend('getSheetData', { sheetId, tab: 'config' });\n\n  const dropdownMap = await callBackend('getSheetData', { sheetId, tab: 'dropdowns' });\n  \n  const finalData = { configRows, dropdownMap };\n\n  sessionStorage.setItem(cacheKey, JSON.stringify({ data: finalData, timestamp: Date.now() }));\n\n  return finalData;\n\n}\n"],"mappings":"AAAA,SAASA,WAAW,EAAEC,eAAe,QAAQ,sBAAsB;AAEnE,OAAO,eAAeC,kBAAkBA,CAACC,MAAM,EAAE;EAAA,IAAAC,gBAAA,EAAAC,qBAAA,EAAAC,qBAAA;EAC/C,MAAMC,QAAQ,GAAG,GAAGJ,MAAM,kBAAkB;EAC5C,MAAMK,MAAM,GAAGC,IAAI,CAACC,KAAK,CAACC,cAAc,CAACC,OAAO,CAACL,QAAQ,CAAC,CAAC;EAC3D,MAAMM,aAAa,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI;EAExC,IAAIL,MAAM,IAAIM,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGP,MAAM,CAACQ,SAAS,GAAGH,aAAa,EAAE;IAC3D,OAAOL,MAAM,CAACS,IAAI;EACpB;EAEA,IAAIC,eAAe,GAAGT,IAAI,CAACC,KAAK,CAACC,cAAc,CAACC,OAAO,CAAC,iBAAiB,CAAC,CAAC;;EAE3E;EACA,IAAI,CAACM,eAAe,IAAI,CAACA,eAAe,CAACD,IAAI,EAAE;IAC7CE,OAAO,CAACC,GAAG,CAAC,wEAAwE,CAAC;IACrF,MAAMnB,eAAe,CAAC,IAAI,CAAC,CAAC,CAAC;IAC7BiB,eAAe,GAAGT,IAAI,CAACC,KAAK,CAACC,cAAc,CAACC,OAAO,CAAC,iBAAiB,CAAC,CAAC;EACzE;EAEA,MAAMS,OAAO,IAAAjB,gBAAA,GAAGc,eAAe,cAAAd,gBAAA,wBAAAC,qBAAA,GAAfD,gBAAA,CAAiBa,IAAI,cAAAZ,qBAAA,uBAArBA,qBAAA,CAAuBiB,IAAI,CAACC,KAAK,IAC/CA,KAAK,CAACC,OAAO,CAACC,IAAI,CAACC,GAAG,IAAIA,GAAG,CAACvB,MAAM,KAAKA,MAAM,CACjD,CAAC;EAED,MAAMwB,OAAO,GAAGN,OAAO,aAAPA,OAAO,wBAAAf,qBAAA,GAAPe,OAAO,CAAEG,OAAO,CAACF,IAAI,CAACM,CAAC,IAAIA,CAAC,CAACzB,MAAM,KAAKA,MAAM,CAAC,cAAAG,qBAAA,uBAA/CA,qBAAA,CAAiDqB,OAAO;EACxE,IAAI,CAACA,OAAO,EAAE,MAAM,IAAIE,KAAK,CAAC,wBAAwB1B,MAAM,EAAE,CAAC;;EAEjE;EACE,MAAM2B,UAAU,GAAG,MAAM9B,WAAW,CAAC,cAAc,EAAE;IAAE2B,OAAO;IAAEI,GAAG,EAAE;EAAS,CAAC,CAAC;EAEhF,MAAMC,WAAW,GAAG,MAAMhC,WAAW,CAAC,cAAc,EAAE;IAAE2B,OAAO;IAAEI,GAAG,EAAE;EAAY,CAAC,CAAC;EAEpF,MAAME,SAAS,GAAG;IAAEH,UAAU;IAAEE;EAAY,CAAC;EAE7CrB,cAAc,CAACuB,OAAO,CAAC3B,QAAQ,EAAEE,IAAI,CAAC0B,SAAS,CAAC;IAAElB,IAAI,EAAEgB,SAAS;IAAEjB,SAAS,EAAEF,IAAI,CAACC,GAAG,CAAC;EAAE,CAAC,CAAC,CAAC;EAE5F,OAAOkB,SAAS;AAElB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}