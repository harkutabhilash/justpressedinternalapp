{"ast":null,"code":"// src/utils/dropdownProvider.js\nimport { fetchMasterData } from './moduleMasterAPI';\nfunction unwrapDump(raw) {\n  // Accept {data:{...}, timestamp} OR raw {...}\n  if (!raw) return null;\n  try {\n    const parsed = JSON.parse(raw);\n    if (parsed && parsed.data) return parsed.data; // wrapped\n    if (parsed && parsed.rows && parsed.headers) return parsed; // raw legacy\n    return null;\n  } catch {\n    return null;\n  }\n}\nfunction getDump(module) {\n  return unwrapDump(sessionStorage.getItem(`dump_${module}`));\n}\n\n// Optional: normalize (migrate) legacy raw dumps to wrapped shape when seen\nfunction normalizeDump(module, dumpData) {\n  sessionStorage.setItem(`dump_${module}`, JSON.stringify({\n    data: dumpData,\n    timestamp: Date.now()\n  }));\n}\nexport async function getOptionsFromModuleSource(source) {\n  var _dump;\n  const [module, propRaw] = String(source).split('.');\n  const prop = (propRaw || '').trim();\n  if (!module || !prop) return [];\n\n  // 1) try cache (handles wrapped/raw)\n  let dump = getDump(module);\n\n  // 2) fetch if not cached\n  if (!dump) {\n    dump = await fetchMasterData(module); // returns the RAW dump data\n    // write back in the WRAPPED shape so all writers are consistent\n    normalizeDump(module, dump);\n  }\n  const rows = Array.isArray((_dump = dump) === null || _dump === void 0 ? void 0 : _dump.rows) ? dump.rows : [];\n  if (rows.length === 0) return [];\n\n  // case-insensitive prop resolution\n  let resolvedKey = prop;\n  if (!(resolvedKey in rows[0])) {\n    const lower = prop.toLowerCase();\n    const match = Object.keys(rows[0]).find(k => k.toLowerCase() === lower);\n    if (match) resolvedKey = match;\n  }\n  const uniq = new Set();\n  for (const r of rows) {\n    const v = r === null || r === void 0 ? void 0 : r[resolvedKey]; // ← use resolvedKey\n    if (v !== undefined && v !== null && `${v}`.trim() !== '') {\n      uniq.add(String(v));\n    }\n  }\n  return Array.from(uniq).sort((a, b) => a.localeCompare(b));\n}","map":{"version":3,"names":["fetchMasterData","unwrapDump","raw","parsed","JSON","parse","data","rows","headers","getDump","module","sessionStorage","getItem","normalizeDump","dumpData","setItem","stringify","timestamp","Date","now","getOptionsFromModuleSource","source","_dump","propRaw","String","split","prop","trim","dump","Array","isArray","length","resolvedKey","lower","toLowerCase","match","Object","keys","find","k","uniq","Set","r","v","undefined","add","from","sort","a","b","localeCompare"],"sources":["/Users/abhilash/Downloads/jp-internal-app/src/utils/dropdownProvider.js"],"sourcesContent":["// src/utils/dropdownProvider.js\nimport { fetchMasterData } from './moduleMasterAPI';\n\nfunction unwrapDump(raw) {\n  // Accept {data:{...}, timestamp} OR raw {...}\n  if (!raw) return null;\n  try {\n    const parsed = JSON.parse(raw);\n    if (parsed && parsed.data) return parsed.data;           // wrapped\n    if (parsed && parsed.rows && parsed.headers) return parsed; // raw legacy\n    return null;\n  } catch {\n    return null;\n  }\n}\n\nfunction getDump(module) {\n  return unwrapDump(sessionStorage.getItem(`dump_${module}`));\n}\n\n// Optional: normalize (migrate) legacy raw dumps to wrapped shape when seen\nfunction normalizeDump(module, dumpData) {\n  sessionStorage.setItem(\n    `dump_${module}`,\n    JSON.stringify({ data: dumpData, timestamp: Date.now() })\n  );\n}\n\nexport async function getOptionsFromModuleSource(source) {\n  const [module, propRaw] = String(source).split('.');\n  const prop = (propRaw || '').trim();\n  if (!module || !prop) return [];\n\n  // 1) try cache (handles wrapped/raw)\n  let dump = getDump(module);\n\n  // 2) fetch if not cached\n  if (!dump) {\n    dump = await fetchMasterData(module);              // returns the RAW dump data\n    // write back in the WRAPPED shape so all writers are consistent\n    normalizeDump(module, dump);\n  }\n\n  const rows = Array.isArray(dump?.rows) ? dump.rows : [];\n  if (rows.length === 0) return [];\n\n  // case-insensitive prop resolution\n  let resolvedKey = prop;\n  if (!(resolvedKey in rows[0])) {\n    const lower = prop.toLowerCase();\n    const match = Object.keys(rows[0]).find(k => k.toLowerCase() === lower);\n    if (match) resolvedKey = match;\n  }\n\n  const uniq = new Set();\n  for (const r of rows) {\n    const v = r?.[resolvedKey]; // ← use resolvedKey\n    if (v !== undefined && v !== null && `${v}`.trim() !== '') {\n      uniq.add(String(v));\n    }\n  }\n\n  return Array.from(uniq).sort((a, b) => a.localeCompare(b));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}